package com.emarsys.rdb.connector.mysql.hack

import java.sql.{Connection, ResultSet, SQLWarning, Statement}

class RouterStatement(val statement: Statement) extends Statement {
  def executeQuery(sql: String): ResultSet = measure("statement.executeQuery(sql)")(statement.executeQuery(sql))

  def executeUpdate(sql: String): Int = measure("statement.executeUpdate(sql)")(statement.executeUpdate(sql))

  def close(): Unit = statement.close()

  def getMaxFieldSize: Int = statement.getMaxFieldSize

  def setMaxFieldSize(max: Int): Unit = statement.setMaxFieldSize(max)

  def getMaxRows: Int = statement.getMaxRows

  def setMaxRows(max: Int): Unit = statement.setMaxRows(max)

  def setEscapeProcessing(enable: Boolean): Unit = statement.setEscapeProcessing(enable)

  def getQueryTimeout: Int = statement.getQueryTimeout

  def setQueryTimeout(seconds: Int): Unit = statement.setQueryTimeout(seconds)

  def cancel(): Unit = statement.cancel()

  def getWarnings: SQLWarning = statement.getWarnings

  def clearWarnings(): Unit = statement.clearWarnings()

  def setCursorName(name: String): Unit = statement.setCursorName(name)

  def execute(sql: String): Boolean = measure("statement.execute(sql)")(statement.execute(sql))

  def getResultSet: ResultSet = statement.getResultSet

  def getUpdateCount: Int = statement.getUpdateCount

  def getMoreResults: Boolean = statement.getMoreResults

  def setFetchDirection(direction: Int): Unit = statement.setFetchDirection(direction)

  def getFetchDirection: Int = statement.getFetchDirection

  def setFetchSize(rows: Int): Unit = statement.setFetchSize(rows)

  def getFetchSize: Int = statement.getFetchSize

  def getResultSetConcurrency: Int = statement.getResultSetConcurrency

  def getResultSetType: Int = statement.getResultSetType

  def addBatch(sql: String): Unit = statement.addBatch(sql)

  def clearBatch(): Unit = statement.clearBatch()

  def executeBatch(): Array[Int] = measure("statement.executeBatch()")(statement.executeBatch())

  def getConnection: Connection = statement.getConnection

  def getMoreResults(current: Int): Boolean = statement.getMoreResults(current)

  def getGeneratedKeys: ResultSet = statement.getGeneratedKeys

  def executeUpdate(sql: String, autoGeneratedKeys: Int): Int = measure("statement.executeUpdate(sql, autoGeneratedKeys)")(statement.executeUpdate(sql, autoGeneratedKeys))

  def executeUpdate(sql: String, columnIndexes: Array[Int]): Int = measure("statement.executeUpdate(sql, columnIndexes)")(statement.executeUpdate(sql, columnIndexes))

  def executeUpdate(sql: String, columnNames: Array[String]): Int = measure("statement.executeUpdate(sql, columnNames)")(statement.executeUpdate(sql, columnNames))

  def execute(sql: String, autoGeneratedKeys: Int): Boolean = measure("statement.execute(sql, autoGeneratedKeys)")(statement.execute(sql, autoGeneratedKeys))

  def execute(sql: String, columnIndexes: Array[Int]): Boolean = measure("statement.execute(sql, columnIndexes)")(statement.execute(sql, columnIndexes))

  def execute(sql: String, columnNames: Array[String]): Boolean = measure("statement.execute(sql, columnNames)")(statement.execute(sql, columnNames))

  def getResultSetHoldability: Int = statement.getResultSetHoldability

  def isClosed: Boolean = statement.isClosed

  def setPoolable(poolable: Boolean): Unit = statement.setPoolable(poolable)

  def isPoolable: Boolean = statement.isPoolable

  def closeOnCompletion(): Unit = statement.closeOnCompletion()

  def isCloseOnCompletion: Boolean = statement.isCloseOnCompletion

  override def getLargeUpdateCount: Long = statement.getLargeUpdateCount

  override def setLargeMaxRows(max: Long): Unit = statement.setLargeMaxRows(max)

  override def getLargeMaxRows: Long = statement.getLargeMaxRows

  override def executeLargeBatch(): Array[Long] = measure("statement.executeLargeBatch()")(statement.executeLargeBatch())

  override def executeLargeUpdate(sql: String): Long = measure("statement.executeLargeUpdate(sql)")(statement.executeLargeUpdate(sql))

  override def executeLargeUpdate(sql: String, autoGeneratedKeys: Int): Long = measure("statement.executeLargeUpdate(sql, autoGeneratedKeys)")(statement.executeLargeUpdate(sql, autoGeneratedKeys))

  override def executeLargeUpdate(sql: String, columnIndexes: Array[Int]): Long = measure("statement.executeLargeUpdate(sql, columnIndexes)")(statement.executeLargeUpdate(sql, columnIndexes))

  override def executeLargeUpdate(sql: String, columnNames: Array[String]): Long = measure("statement.executeLargeUpdate(sql, columnNames)")(statement.executeLargeUpdate(sql, columnNames))

  override def enquoteLiteral(`val`: String): String = statement.enquoteLiteral(`val`)

  override def enquoteIdentifier(identifier: String, alwaysQuote: Boolean): String = statement.enquoteIdentifier(identifier, alwaysQuote)

  override def isSimpleIdentifier(identifier: String): Boolean = statement.isSimpleIdentifier(identifier)

  override def enquoteNCharLiteral(`val`: String): String = statement.enquoteNCharLiteral(`val`)

  def unwrap[T](iface: Class[T]): T = statement.unwrap(iface)

  def isWrapperFor(iface: Class[_]): Boolean = statement.isWrapperFor(iface)

  private def measure[A](name: String)(f: => A): A = {
    val start = System.nanoTime()
    val res = f
    val end = System.nanoTime()

    println(s"$name: ${(end - start) / 1e6f}ms")
    res
  }
}
